<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corriente Sound - Music Discovery with ReccoBeats</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #7c3aed 50%, #1e1b4b 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #03fca5, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #d1d5db;
            font-size: 1.1rem;
        }

        .auth-section {
            background: rgba(31, 41, 55, 0.8);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(3, 252, 165, 0.3);
            text-align: center;
        }

        .auth-section.hidden {
            display: none;
        }

        .spotify-btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            background: #1db954;
            color: white;
            text-decoration: none;
            border-radius: 12px;
            font-weight: 600;
            transition: background-color 0.3s;
            border: none;
            cursor: pointer;
        }

        .spotify-btn:hover {
            background: #1aa34a;
        }

        .search-section {
            background: rgba(31, 41, 55, 0.8);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(3, 252, 165, 0.3);
        }

        .search-section.hidden {
            display: none;
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #374151;
            border-radius: 12px;
            background: #1f2937;
            color: white;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #03fca5;
        }

        .search-input::placeholder {
            color: #9ca3af;
        }

        .search-results {
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .search-results.show {
            display: block;
        }

        .selected-song {
            display: none;
            background: #374151;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid #03fca5;
        }

        .selected-song.show {
            display: block;
        }

        .song-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .song-artwork {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
        }

        .song-artwork-placeholder {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #03fca5, #ec4899);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .song-details h3 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .song-details p {
            color: #d1d5db;
            font-size: 0.9rem;
        }

        .play-btn {
            padding: 10px 15px;
            background: linear-gradient(45deg, #03fca5, #ec4899);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.3s;
            min-width: 50px;
        }

        .play-btn:hover {
            transform: scale(1.05);
        }

        .play-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* New audio features debug section */
        .audio-features-debug {
            display: none;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(3, 252, 165, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
        }

        .audio-features-debug.show {
            display: block;
        }

        /* Similar song suggestion section */
        .similar-song-section {
            display: none;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .similar-song-section.show {
            display: block;
        }
        
        .similar-song-header {
            color: #ec4899;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .similar-song-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #374151;
            border-radius: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
            cursor: pointer;
        }
        
        .similar-song-item:hover {
            background: #4b5563;
        }
        
        .pipeline-info {
            font-size: 0.8rem;
            color: #9ca3af;
            margin-top: 10px;
            font-style: italic;
        }
        
        .test-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #ec4899, #a855f7);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .test-btn:hover {
            transform: scale(1.05);
        }
        
                

        .debug-header {
            color: #03fca5;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            font-size: 0.8rem;
        }

        .feature-item {
            background: rgba(31, 41, 55, 0.5);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
        }

        .feature-name {
            color: #9ca3af;
        }

        .feature-value {
            color: #03fca5;
            font-weight: bold;
        }

        .mood-section {
            display: none;
            background: rgba(31, 41, 55, 0.8);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(3, 252, 165, 0.3);
        }

        .mood-section.show {
            display: block;
        }

        .mood-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .mood-subtitle {
            color: #d1d5db;
            text-align: center;
            margin-bottom: 25px;
        }

        .mood-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .mood-btn {
            padding: 20px;
            border: 2px solid #374151;
            border-radius: 12px;
            background: #1f2937;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 1rem;
            font-weight: 500;
        }

        .mood-btn:hover {
            border-color: #03fca5;
            transform: translateY(-2px);
        }

        .mood-btn.selected {
            background: #03fca5;
            border-color: #03fca5;
            box-shadow: 0 10px 20px rgba(3, 252, 165, 0.3);
        }

        .mood-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            display: block;
        }

        .generate-btn {
            display: none;
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #03fca5, #ec4899);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .generate-btn.show {
            display: block;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
        }

        .playlist-section {
            display: none;
            background: rgba(31, 41, 55, 0.8);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(3, 252, 165, 0.3);
        }

        .playlist-section.show {
            display: block;
        }

        .playlist-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .playlist-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .playlist-meta {
            color: #d1d5db;
            font-size: 0.9rem;
        }

        .playlist-tracks {
            space-y: 10px;
        }

        .track-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #374151;
            border-radius: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
            cursor: pointer;
        }

        .track-item:hover {
            background: #4b5563;
        }

        .track-number {
            width: 30px;
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .track-artwork {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            margin-right: 15px;
            object-fit: cover;
        }

        .track-artwork-placeholder {
            width: 40px;
            height: 40px;
            background: #6b7280;
            border-radius: 6px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .track-info {
            flex: 1;
        }

        .track-title {
            font-weight: 500;
            margin-bottom: 3px;
        }

        .track-artist {
            color: #d1d5db;
            font-size: 0.9rem;
        }

        .mood-tag {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 10px;
        }

        .mood-upbeat { background: rgba(249, 115, 22, 0.3); color: #fb923c; }
        .mood-chill { background: rgba(34, 197, 94, 0.3); color: #4ade80; }
        .mood-groovy { background: rgba(3, 252, 165, 0.3); color: #03fca5; }
        .mood-romantic { background: rgba(236, 72, 153, 0.3); color: #ec4899; }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #d1d5db;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .service-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(31, 41, 55, 0.95);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #d1d5db;
            border: 1px solid rgba(3, 252, 165, 0.3);
            z-index: 1000;
        }

        .service-status .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .service-status .status-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">Corriente Sound</h1>
            <p class="subtitle">Play your Current</p>
        </div>

        <!-- Authentication Section -->
        <div class="auth-section" id="authSection">
            <h2 style="margin-bottom: 20px;">Connect to Music Services</h2>
            <p style="margin-bottom: 25px; color: #d1d5db;">
                We use Spotify for song search and ReccoBeats for advanced audio analysis and mood detection.
            </p>
            <button class="spotify-btn" onclick="authenticateSpotify()">
                üéµ Connect Music Services
            </button>
        </div>

        <!-- Error Display -->
        <div class="error" id="errorDisplay"></div>

        <!-- Loading Indicator -->
        <div class="loading" id="loadingIndicator">
            <div style="font-size: 2rem; margin-bottom: 10px;">üéµ</div>
            <p>Loading...</p>
        </div>

        <!-- Song Search Section -->
        <div class="search-section hidden" id="searchSection">
            <h2 style="margin-bottom: 15px; text-align: center;">Start with a song you love</h2>
            <input 
                type="text" 
                class="search-input" 
                id="songSearch"
                placeholder="Search for any song on Spotify..."
            >
            
            <!-- Real Spotify search results -->
            <div id="searchResults" class="search-results"></div>

            <!-- Selected Song Display -->
            <div class="selected-song" id="selectedSong">
                <div class="song-info">
                    <img id="selectedArtwork" class="song-artwork" style="display: none;" />
                    <div class="song-artwork-placeholder" id="artworkPlaceholder">üéµ</div>
                    <div class="song-details">
                        <h3 id="selectedTitle">Song Title</h3>
                        <p id="selectedArtist">Artist Name</p>
                        <p id="selectedAlbum" style="font-size: 0.8rem; color: #9ca3af;"></p>
                    </div>
                    <button class="play-btn" id="playBtn" onclick="togglePlay()">
                        <span id="playIcon">‚ñ∂Ô∏è</span>
                    </button>
                </div>

                <!-- Audio Features Debug Section -->
                <div class="audio-features-debug" id="audioFeaturesDebug">
                    <div class="debug-header">üéØ ReccoBeats Audio Features Analysis</div>
                    <div class="feature-grid" id="featureGrid">
                        <!-- Features will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Similar Song Test Section -->
            <div class="similar-song-section" id="similarSongSection">
                <div class="similar-song-header">
                    üéµ Similar Song Test
                    <button class="test-btn" onclick="findSimilarSong()">Find Similar</button>
                </div>
                <div id="similarSongResult">
                    <!-- Similar song will be displayed here -->
                </div>
                <div class="pipeline-info" id="pipelineInfo">
                    <!-- Pipeline information will be shown here -->
                </div>
            </div>
        </div>

        <!-- Mood Selection Section -->
        <div class="mood-section" id="moodSection">
            <h2 class="mood-title">Where should we take this playlist?</h2>
            <p class="mood-subtitle">Select the mood directions you want to explore</p>
            
            <div class="mood-buttons">
                <button class="mood-btn" onclick="toggleMood(this, 'upbeat')">
                    <span class="mood-icon">‚ö°</span>
                    More Upbeat
                </button>
                <button class="mood-btn" onclick="toggleMood(this, 'chill')">
                    <span class="mood-icon">üåä</span>
                    More Chill
                </button>
                <button class="mood-btn" onclick="toggleMood(this, 'groovy')">
                    <span class="mood-icon">üï∫</span>
                    More Groovy
                </button>
                <button class="mood-btn" onclick="toggleMood(this, 'romantic')">
                    <span class="mood-icon">üíï</span>
                    More Romantic
                </button>
            </div>

            <button class="generate-btn" id="generateBtn" onclick="generatePlaylist()">
                üéØ Generate My Corriente Playlist
            </button>
        </div>

        <!-- Generated Playlist Section -->
        <div class="playlist-section" id="playlistSection">
            <div class="playlist-header">
                <h2 class="playlist-title">Your Corriente Playlist</h2>
                <p class="playlist-meta" id="playlistMeta">Generating...</p>
            </div>

            <div class="playlist-tracks" id="playlistTracks">
                <!-- Real Spotify tracks will be populated here -->
            </div>
        </div>
    </div>

    <!-- Service Status Indicator -->
    <div class="service-status" id="serviceStatus" style="display: none;">
        <div class="status-item">üîç <span>Search: Spotify</span></div>
        <div class="status-item">üéØ <span>Analysis: ReccoBeats</span></div>
    </div>

    <script>
        // API Configuration - Now points to our backend with ReccoBeats integration
        const API_BASE = window.location.origin.includes('localhost') ? 
            'http://localhost:3001/api' : '/api';

        let isAuthenticated = false;
        let selectedMoods = [];
        let currentSong = null;
        let currentAudioFeatures = null; // Store current song's features
        let searchTimeout = null;
        let currentAudio = null;

        // Enhanced error handling for ReccoBeats integration
        function showError(message, details = null) {
            const errorDiv = document.getElementById('errorDisplay');
            
            // Enhanced error messages for better user experience
            let displayMessage = message;
            
            if (message.includes('Failed to get audio features')) {
                displayMessage = 'Unable to analyze this song\'s mood characteristics. Please try a different track.';
            } else if (message.includes('Failed to generate recommendations')) {
                displayMessage = 'Could not generate playlist recommendations. Please try again with a different song.';
            } else if (message.includes('Search failed')) {
                displayMessage = 'Song search is temporarily unavailable. Please try again.';
            }
            
            errorDiv.textContent = displayMessage;
            errorDiv.classList.add('show');
            
            // Log detailed error for debugging
            if (details) {
                console.error('Detailed error:', details);
            }
            
            // Auto-hide after 7 seconds (longer for integration issues)
            setTimeout(() => {
                errorDiv.classList.remove('show');
            }, 7000);
        }

        // Enhanced authentication with service information
        async function authenticateSpotify() {
            showLoading(true);
            
            try {
                const response = await fetch(`${API_BASE}/auth`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Authentication failed');
                }

                const data = await response.json();
                if (data.success) {
                    isAuthenticated = true;
                    
                    // Hide auth section, show search
                    document.getElementById('authSection').classList.add('hidden');
                    document.getElementById('searchSection').classList.remove('hidden');
                    
                    console.log('‚úÖ Music services connected successfully!');
                    console.log('üéµ Search: Spotify API');
                    console.log('üéØ Analysis: ReccoBeats API');
                    
                    // Show service status briefly
                    showServiceStatus();
                } else {
                    throw new Error(data.error || 'Authentication failed');
                }
                
            } catch (error) {
                showError('Failed to connect to music services: ' + error.message);
            }
            
            showLoading(false);
        }

        // Search for songs via backend (Spotify)
        async function searchSpotify(query) {
            if (!isAuthenticated) {
                showError('Not authenticated with music services');
                return [];
            }

            try {
                const response = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}`);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Search request failed');
                }

                const tracks = await response.json();
                return tracks;
            } catch (error) {
                showError('Search failed: ' + error.message);
                return [];
            }
        }

        // Enhanced audio features fetching with better error handling and debug display
        async function getAudioFeatures(trackId) {
            try {
                console.log(`üéØ Getting audio features for track: ${trackId}`);
                
                const response = await fetch(`${API_BASE}/audio-features/${trackId}`);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}: Failed to get audio features`);
                }

                const features = await response.json();
                
                // Validate that we got the expected audio features
                const requiredFeatures = ['energy', 'danceability', 'valence', 'tempo'];
                const missingFeatures = requiredFeatures.filter(feature => 
                    features[feature] === undefined || features[feature] === null
                );
                
                if (missingFeatures.length > 0) {
                    console.warn('Missing audio features:', missingFeatures);
                    showError('This song has incomplete analysis data. Try a different track.');
                    return null;
                }
                
                console.log('‚úÖ Audio features received:', features);
                
                // Store features and update debug display
                currentAudioFeatures = features;
                updateAudioFeaturesDebug(features);
                
                return features;
                
            } catch (error) {
                console.error('Audio features error:', error);
                showError('Failed to analyze song characteristics: ' + error.message);
                return null;
            }
        }

        // Display audio features in debug section
        function updateAudioFeaturesDebug(features) {
            const debugSection = document.getElementById('audioFeaturesDebug');
            const featureGrid = document.getElementById('featureGrid');
            
            // Clear previous content
            featureGrid.innerHTML = '';
            
            // Define feature display names and formatting
            const featureDefinitions = {
                'acousticness': { name: 'Acoustic', format: (v) => (v * 100).toFixed(1) + '%' },
                'danceability': { name: 'Danceable', format: (v) => (v * 100).toFixed(1) + '%' },
                'energy': { name: 'Energy', format: (v) => (v * 100).toFixed(1) + '%' },
                'instrumentalness': { name: 'Instrumental', format: (v) => (v * 100).toFixed(1) + '%' },
                'liveness': { name: 'Live', format: (v) => (v * 100).toFixed(1) + '%' },
                'loudness': { name: 'Loudness', format: (v) => v.toFixed(1) + 'dB' },
                'speechiness': { name: 'Speech', format: (v) => (v * 100).toFixed(1) + '%' },
                'tempo': { name: 'Tempo', format: (v) => Math.round(v) + ' BPM' },
                'valence': { name: 'Positivity', format: (v) => (v * 100).toFixed(1) + '%' }
            };
            
            // Create feature items
            Object.entries(features).forEach(([key, value]) => {
                if (featureDefinitions[key] && value !== undefined && value !== null) {
                    const featureItem = document.createElement('div');
                    featureItem.className = 'feature-item';
                    
                    const definition = featureDefinitions[key];
                    featureItem.innerHTML = `
                        <span class="feature-name">${definition.name}</span>
                        <span class="feature-value">${definition.format(value)}</span>
                    `;
                    
                    featureGrid.appendChild(featureItem);
                }
            });
            
            // Show debug section
            debugSection.classList.add('show');
        }

        // Enhanced recommendation generation with ReccoBeats
        async function getRecommendations(seedTrackId, moods) {
            try {
                console.log(`üéµ Getting recommendations for ${seedTrackId} with moods: ${moods.join(', ')}`);
                
                // Use stored features if available, otherwise fetch them
                let features = currentAudioFeatures;
                if (!features) {
                    features = await getAudioFeatures(seedTrackId);
                    if (!features) {
                        throw new Error('Could not analyze seed track');
                    }
                }

                // Calculate target features based on selected moods (same logic as before)
                let targetFeatures = {
                    seed_tracks: seedTrackId,
                    limit: 9,
                    target_energy: features.energy,
                    target_danceability: features.danceability,
                    target_valence: features.valence,
                    target_tempo: features.tempo
                };

                // Adjust features based on selected moods
                moods.forEach(mood => {
                    switch(mood) {
                        case 'upbeat':
                            targetFeatures.target_energy = Math.min(1.0, features.energy + 0.3);
                            targetFeatures.target_tempo = Math.min(200, features.tempo + 40);
                            break;
                        case 'chill':
                            targetFeatures.target_energy = Math.max(0.1, features.energy - 0.3);
                            targetFeatures.target_tempo = Math.max(60, features.tempo - 40);
                            break;
                        case 'groovy':
                            targetFeatures.target_danceability = Math.min(1.0, features.danceability + 0.3);
                            break;
                        case 'romantic':
                            targetFeatures.target_valence = Math.min(1.0, features.valence + 0.2);
                            targetFeatures.target_energy = Math.max(0.2, features.energy - 0.2);
                            break;
                    }
                });

                // Log target features for debugging
                console.log('Target features:', targetFeatures);

                // Build query string for backend
                const queryParams = new URLSearchParams(targetFeatures);
                
                const response = await fetch(`${API_BASE}/recommendations?${queryParams}`);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to get recommendations');
                }

                const tracks = await response.json();
                
                // Validate that we got actual tracks back
                if (!Array.isArray(tracks) || tracks.length === 0) {
                    console.warn('No recommendations returned');
                    return [];
                }
                
                console.log(`‚úÖ Got ${tracks.length} recommendations`);
                return tracks;
                
            } catch (error) {
                console.error('Recommendations error:', error);
                showError('Failed to generate playlist: ' + error.message);
                return [];
            }
        }
        // Test similar song functionality
        async function findSimilarSong() {
            if (!currentSong) {
                showError('No song selected');
                return;
            }
            
            console.log('üîç Finding similar song for:', currentSong.name);
            showLoading(true);
            
            try {
                const response = await fetch(`${API_BASE}/similar-song/${currentSong.id}`);
                
                if (!response.ok) {
                    throw new Error('Failed to find similar song');
                }
                
                const data = await response.json();
                console.log('Similar song response:', data);
                
                // Display results
                displaySimilarSong(data);
                
                // Show the section
                document.getElementById('similarSongSection').classList.add('show');
                
            } catch (error) {
                console.error('Similar song error:', error);
                showError('Failed to find similar song: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Display similar song results
        function displaySimilarSong(data) {
            const resultDiv = document.getElementById('similarSongResult');
            const pipelineDiv = document.getElementById('pipelineInfo');
            
            if (data.similarTrack) {
                const track = data.similarTrack;
                const artwork = track.album?.images?.length > 0 ? 
                    `<img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-artwork" />` :
                    `<div class="track-artwork-placeholder">üéµ</div>`;
                
                resultDiv.innerHTML = `
                    <div class="similar-song-item" onclick="openInSpotify('${track.external_urls?.spotify || '#'}')">
                        ${artwork}
                        <div class="track-info">
                            <div class="track-title">${track.name}</div>
                            <div class="track-artist">${track.artists[0].name}</div>
                        </div>
                        <span style="color: #ec4899; font-size: 0.8rem; margin-left: auto;">‚ú® Similar</span>
                    </div>
                `;
                
                // Show pipeline info
                let pipelineText = `Pipeline: ${data.pipeline.method}`;
                if (data.pipeline.reccobeatsUsed) {
                    pipelineText += ' ‚úÖ ReccoBeats ‚Üí Spotify';
                } else {
                    pipelineText += ' üéØ Feature-based Spotify search';
                }
                pipelineDiv.textContent = pipelineText;
                
            } else {
                resultDiv.innerHTML = '<p style="color: #9ca3af;">No similar song found</p>';
                pipelineDiv.textContent = 'Pipeline test completed - check server logs for details';
            }
        }

        // Initialize search functionality
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('songSearch');
            
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                if (query.length > 2) {
                    // Debounce search
                    searchTimeout = setTimeout(() => {
                        performSearch(query);
                    }, 500);
                } else {
                    document.getElementById('searchResults').classList.remove('show');
                }
            });
        });

        async function performSearch(query) {
            showLoading(true);
            
            const tracks = await searchSpotify(query);
            const resultsDiv = document.getElementById('searchResults');
            
            if (tracks && tracks.length > 0) {
                resultsDiv.innerHTML = '';
                
                tracks.forEach((track, index) => {
                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'track-item';
                    trackDiv.onclick = () => selectSong(track);
                    
                    const artwork = track.album.images.length > 0 ? 
                        `<img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-artwork" />` :
                        `<div class="track-artwork-placeholder">üéµ</div>`;
                    
                    // Add preview indicator
                    const previewIndicator = track.preview_url ? 
                        '<span style="color: #03fca5; font-size: 0.8rem;">‚ñ∂Ô∏è Preview</span>' : 
                        '<span style="color: #9ca3af; font-size: 0.8rem;">‚ùå No preview</span>';
                    
                    trackDiv.innerHTML = `
                        <span class="track-number">üéµ</span>
                        ${artwork}
                        <div class="track-info">
                            <div class="track-title">${track.name}</div>
                            <div class="track-artist">${track.artists[0].name}</div>
                            <div>${previewIndicator}</div>
                        </div>
                    `;
                    
                    resultsDiv.appendChild(trackDiv);
                });
                
                resultsDiv.classList.add('show');
            }
            
            showLoading(false);
        }

        async function selectSong(track) {
            currentSong = track;
            currentAudioFeatures = null; // Reset features
            
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                updatePlayButton(false);
            }
            
            // Update selected song display
            document.getElementById('selectedTitle').textContent = track.name;
            document.getElementById('selectedArtist').textContent = track.artists[0].name;
            document.getElementById('selectedAlbum').textContent = track.album.name;
            
            // Update artwork
            const artworkImg = document.getElementById('selectedArtwork');
            const artworkPlaceholder = document.getElementById('artworkPlaceholder');
            
            if (track.album.images.length > 0) {
                artworkImg.src = track.album.images[1]?.url || track.album.images[0]?.url;
                artworkImg.style.display = 'block';
                artworkPlaceholder.style.display = 'none';
            }
            
            // Enable/disable play button based on preview availability
            const playBtn = document.getElementById('playBtn');
            if (track.preview_url) {
                playBtn.disabled = false;
                playBtn.style.opacity = '1';
                playBtn.title = 'Play 30-second preview';
            } else {
                playBtn.disabled = true;
                playBtn.style.opacity = '0.5';
                playBtn.title = 'No preview available for this song';
            }
            
            // Show selected song
            document.getElementById('selectedSong').classList.add('show');
            
            // Hide search results
            document.getElementById('searchResults').classList.remove('show');

            // In your selectSong function, add this line after showing the debug section:
            document.getElementById('similarSongSection').classList.add('show');
            
            // Get audio features immediately and show debug info
            console.log('üéØ Fetching audio features for selected song...');
            showLoading(true);
            
            try {
                const features = await getAudioFeatures(track.id);
                if (features) {
                    // Show mood section after successful feature extraction
                    document.getElementById('moodSection').classList.add('show');
                    
                    // Scroll to mood section
                    document.getElementById('moodSection').scrollIntoView({ behavior: 'smooth' });
                } else {
                    showError('Could not analyze this song. Please try a different track.');
                }
            } catch (error) {
                console.error('Error getting audio features:', error);
                showError('Failed to analyze song: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function toggleMood(button, moodType) {
            if (button.classList.contains('selected')) {
                button.classList.remove('selected');
                selectedMoods = selectedMoods.filter(m => m !== moodType);
            } else {
                button.classList.add('selected');
                selectedMoods.push(moodType);
            }

            // Show generate button if any mood is selected
            const generateBtn = document.getElementById('generateBtn');
            if (selectedMoods.length > 0) {
                generateBtn.classList.add('show');
            } else {
                generateBtn.classList.remove('show');
            }
        }

        // Enhanced playlist generation with better feedback
        async function generatePlaylist() {
            if (selectedMoods.length === 0 || !currentSong) return;

            showLoading(true);
            
            // Update UI to show progress
            const playlistSection = document.getElementById('playlistSection');
            const metaDiv = document.getElementById('playlistMeta');
            metaDiv.textContent = 'Analyzing song and generating recommendations...';
            playlistSection.classList.add('show');
            playlistSection.scrollIntoView({ behavior: 'smooth' });
            
            try {
                // Get recommendations using ReccoBeats backend
                const recommendations = await getRecommendations(currentSong.id, selectedMoods);
                
                if (recommendations.length === 0) {
                    metaDiv.textContent = 'Could not generate recommendations for this song. Try a different track or mood combination.';
                    showError('No recommendations available for this combination');
                    return;
                }
                
                // Build playlist (original song + recommendations)
                const playlist = [currentSong, ...recommendations];
                
                // Display playlist
                displayPlaylist(playlist);
                
            } catch (error) {
                console.error('Playlist generation failed:', error);
                metaDiv.textContent = 'Playlist generation failed. Please try again.';
                showError('Failed to generate playlist: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function displayPlaylist(playlist) {
            const tracksDiv = document.getElementById('playlistTracks');
            const metaDiv = document.getElementById('playlistMeta');
            
            tracksDiv.innerHTML = '';
            metaDiv.textContent = `${playlist.length} songs ‚Ä¢ Generated with moods: ${selectedMoods.join(', ')} ‚Ä¢ Powered by ReccoBeats`;

            playlist.forEach((track, index) => {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'track-item';
                trackDiv.onclick = () => openInSpotify(track.external_urls?.spotify || '#');
                
                const artwork = track.album?.images?.length > 0 ? 
                    `<img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-artwork" />` :
                    `<div class="track-artwork-placeholder">üéµ</div>`;
                
                // Determine mood tag based on position and selected moods
                const moodTag = index === 0 ? 'original' : selectedMoods[Math.floor(Math.random() * selectedMoods.length)];
                const moodClass = `mood-${moodTag}`;
                
                trackDiv.innerHTML = `
                    <span class="track-number">${index + 1}</span>
                    ${artwork}
                    <div class="track-info">
                        <div class="track-title">${track.name || 'Unknown Track'}</div>
                        <div class="track-artist">${track.artists?.[0]?.name || 'Unknown Artist'}</div>
                    </div>
                    <span class="mood-tag ${moodClass}">${moodTag}</span>
                `;
                
                tracksDiv.appendChild(trackDiv);
            });

            // Show playlist section
            document.getElementById('playlistSection').classList.add('show');
            document.getElementById('playlistSection').scrollIntoView({ behavior: 'smooth' });
        }

        function openInSpotify(url) {
            if (url && url !== '#') {
                window.open(url, '_blank');
            }
        }

        // Play/pause functionality
        function togglePlay() {
            if (!currentSong) {
                showError('No song selected');
                return;
            }
            
            if (!currentSong.preview_url) {
                showError('No preview available for this song');
                return;
            }

            if (currentAudio && !currentAudio.paused) {
                // Pause current audio
                currentAudio.pause();
                updatePlayButton(false);
            } else {
                // Stop any previous audio
                if (currentAudio) {
                    currentAudio.pause();
                }
                
                // Play new audio
                currentAudio = new Audio(currentSong.preview_url);
                
                currentAudio.play().then(() => {
                    updatePlayButton(true);
                }).catch(error => {
                    console.error('Audio play error:', error);
                    showError('Failed to play audio: ' + error.message);
                });

                // Handle audio end
                currentAudio.addEventListener('ended', () => {
                    updatePlayButton(false);
                });
                
                // Handle audio errors
                currentAudio.addEventListener('error', (e) => {
                    console.error('Audio error:', e);
                    showError('Audio playback failed');
                    updatePlayButton(false);
                });
            }
        }

        function updatePlayButton(isPlaying) {
            const playIcon = document.getElementById('playIcon');
            playIcon.textContent = isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
        }

        // Show service status indicator
        function showServiceStatus() {
            const statusDiv = document.getElementById('serviceStatus');
            statusDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        // Utility functions
        function showLoading(show) {
            const loading = document.getElementById('loadingIndicator');
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        // Handle URL parameters for Spotify callback
        window.addEventListener('load', function() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');
            
            if (code) {
                // Handle Spotify callback (for future user auth)
                console.log('Spotify callback code:', code);
            }
            
            // Show initial service status
            setTimeout(showServiceStatus, 1000);
        });
    </script>
</body>
</html>
